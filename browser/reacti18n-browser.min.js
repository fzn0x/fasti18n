!(function (e, t) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = t(require('{}')))
    : 'function' == typeof define && define.amd
      ? define('yoi18n', ['{}'], t)
      : 'object' == typeof exports
        ? (exports.yoi18n = t(require('{}')))
        : (e.yoi18n = t(e['{}']))
})(self, (e) =>
  (() => {
    'use strict'
    var t = {
        324: (t) => {
          t.exports = e
        },
      },
      n = {}
    function o(e) {
      var r = n[e]
      if (void 0 !== r) return r.exports
      var i = (n[e] = { exports: {} })
      return t[e](i, i.exports, o), i.exports
    }
    ;(o.n = (e) => {
      var t = e && e.__esModule ? () => e.default : () => e
      return o.d(t, { a: t }), t
    }),
      (o.d = (e, t) => {
        for (var n in t)
          o.o(t, n) && !o.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] })
      }),
      (o.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
      (o.r = (e) => {
        'undefined' != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }),
          Object.defineProperty(e, '__esModule', { value: !0 })
      })
    var r = {}
    o.r(r), o.d(r, { default: () => u })
    var i = o(324)
    function a(e) {
      const t = (function (e) {
        const t = {}
        return e
          ? (e.split(';').forEach((e) => {
              const [n, ...o] = e.split('=')
              n && (t[n.trim()] = decodeURIComponent(o.join('=')))
            }),
            t)
          : t
      })(e)
      return t.lang || null
    }
    function c(e) {
      const t = (function (e) {
        const t = {}
        return e
          ? (e
              .replace(/^\?/, '')
              .split('&')
              .forEach((e) => {
                const [n, o] = e.split('=')
                n && o && (t[n] = decodeURIComponent(o))
              }),
            t)
          : t
      })(e)
      return t.lang || null
    }
    const u = {
      init: function (e) {
        const t = {}
        for (const o in e.namespace) {
          const r = e.namespace[o]
          if (!r) throw new Error('Invalid namespace configuration')
          t[o] =
            ((n = r.load),
            JSON.parse(
              (function (e) {
                return (0, i.readFileSync)(e, 'utf-8')
              })(n)
            ))
        }
        var n
        const o = (function (e) {
          const { order: t, defaultLang: n } = e
          return (e) => {
            for (const n of t) {
              let t = null
              if (
                ('cookie' === n
                  ? (t = a(e.headers.cookie))
                  : 'path' === n
                    ? (t = e.url.split('/').find((e) => /^[a-z]{2}$/.test(e)) || null)
                    : 'query' === n && (t = c(e.url)),
                t)
              )
                return t
            }
            return n
          }
        })(e.detection)
        function r(n, r) {
          var i, a
          const [c, u] = n.split('.'),
            l =
              r && Object.keys(r).length
                ? o(r)
                : (c &&
                    (null ===
                      (a =
                        null === (i = null == e ? void 0 : e.namespace) || void 0 === i
                          ? void 0
                          : i[c]) || void 0 === a
                      ? void 0
                      : a.defaultLang)) ||
                  e.detection.defaultLang
          return c && u && c in t && l in t[c] ? t[c][l][u] || n : t.default[l][n] || n
        }
        return (
          (r.switch = (t, n) => {
            if (((e.detection.defaultLang = t), n)) {
              if (!e.namespace[n]) throw new Error(`Namespace ${n} not found`)
              e.namespace[n].defaultLang = t
            }
          }),
          r
        )
      },
    }
    return r
  })()
)
//# sourceMappingURL=yoi18n-browser.min.js.map
